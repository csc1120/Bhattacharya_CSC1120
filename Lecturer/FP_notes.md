# Functional Programming
## What is Functional Programming?
- Functional programming is a programming paradigm that treats computation as the evaluation of mathematical functions and avoids changing-state and mutable data.
- Programs are constructed by applying and composing functions.
- It is a declarative programming paradigm in which function definitions are trees of expressions that each return a value, rather than a sequence of imperative statements which change the state of the program.
- Treats computation as the evaluation of mathematical functions and avoids changing-state and mutable data.

## Functional Programming Characteristics

- Conceptually, we can think of functional programming as if each method acted like a mathematical function. For a fixed set of inputs, the function returns the same value each time it is called. This results in the following constraints:
- The function call can be replaced by the result. 
- Functions are not allowed to have side effects. 
- The compiler is allowed to rearrange the function invocations or run them on different threads without changing the result. 
- Program flow is driven by data dependencies rather than the sequence of instructions.

## First-Class Functions

- Functional programming involves first-class functions. Put simply, we are able to treat a function like we would data. Specifically:
- Functions can be assigned to variables. 
- Functions can be passed as arguments to another function. 
- Functions can be returned by other functions.

## Why Functional Programming?
- Functional programming can increase the reusability of code, improve readability and testability, and enable the use of powerful programming techniques such as concurrency and parallelization.
- It leads to programs that are more modular and easier to reason about, since functions are designed to not produce side effects.
- It enables developers to write more declarative code, which can be more understandable than imperative code.

## Lambda Expression
- Lambda expression is an anonymous function without a name and access modifier.

## Stream
- A stream is a sequence of elements supporting sequential and parallel aggregate operations.

## Higher-Order Functions
- A higher-order function is a function that takes another function as an argument, returns a function, or does both.

## Consumer Interface
- One common type of function that is passed to higher-order functions is a consumer function -- a function that takes an argument and returns no result. Java provides a functional interface to help: Consumer<T>.
- We can create a consumer function by implementing this interface with a lambda expression. The following defines a consumer function that prints the string on which the consumer is evaluated:
```Consumer<String> print = (word -> System.out.println(word));```
## Supplier Interface
- One common type of function that is passed to higher-order functions is a supplier function -- a function that takes no arguments and returns a result. Java provides a functional interface to help: Supplier<T>.
- We can create a supplier function by implementing this interface with a lambda expression. The following defines a supplier function that returns a random integer between 1 and 100:
```Supplier<Integer> random = () -> (int) (Math.random() * 100) + 1;```
- The Stream interface declares these higher-order functions that require a supplier function:
- ```generate(Supplier<T> s)``` -- returns an infinite sequential unordered stream where each element is generated by the provided Supplier.
- ```iterate(T seed, UnaryOperator<T> f)``` -- returns an infinite sequential ordered stream produced by iterative application of a function f to an initial element seed, producing a stream consisting of seed, f(seed), f(f(seed)), etc.
- ```of(T t)``` -- returns a sequential ordered stream whose elements are all equal to the specified value.
- ```of(T... values)``` -- returns a sequential ordered stream whose elements are the specified values.
- ```empty()``` -- returns an empty sequential stream.

## Function Interface
- One common type of function that is passed to higher-order functions is a function that takes an argument and returns a result. Java provides a functional interface to help: Function<T,R>.
- We can create a function by implementing this interface with a lambda expression. The following defines a function that returns the length of the string on which the function is evaluated:
```Function<String,Integer> length = (word -> word.length());```

## Predicate Interface

- One common type of function that is passed to higher-order functions is a predicate function -- a function that evaluates to a boolean value. Java provides a functional interface to help: Predicate<T>.

- We can create a predicate function by implementing this interface with a lambda expression. The following defines a predicate function that returns true whenever the string on which the predicate is evaluated is longer than nine characters:
The Stream interface declares these higher-order functions that require a predicate function:
- 
```Predicate<String> longerThanNine = (word -> word!=null && word.length()>9);```
- ```allMatch(Predicate<? super T> predicate)``` -- returns true if all elements in this stream match the predicate.
- ```anyMatch(Predicate<? super T> predicate)``` -- returns true if any elements in this stream match the predicate.
- ```noneMatch(Predicate<? super T> predicate)``` -- returns true if none of the elements in this stream match the predicate.
- ```filter(Predicate<? super T> predicate)``` -- returns a stream consisting of the elements of this stream that match the given predicate.


## Map, Reduce, Filter, Collect, Reduce, FlatMap
- The Stream interface declares these higher-order functions that require a function:
- ```map(Function<? super T,? extends R> mapper)``` -- returns a stream consisting of the results of applying the given function to the elements of this stream.
- ```reduce(T identity, BinaryOperator<T> accumulator)``` -- performs a reduction on the elements of this stream, using the provided identity value and an associative accumulation function, and returns the reduced value.
- ```filter(Predicate<? super T> predicate)``` -- returns a stream consisting of the elements of this stream that match the given predicate.
- ```collect(Collector<? super T,A,R> collector)``` -- performs a mutable reduction operation on the elements of this stream using a Collector.
- ```flatMap(Function<? super T,? extends Stream<? extends R>> mapper)``` -- returns a stream consisting of the results of replacing each element of this stream with the contents of a mapped stream produced by applying the provided mapping function to each element.
- ```forEach(Consumer<? super T> action)``` -- performs an action for each element of this stream.
- ```sorted()``` -- returns a stream consisting of the elements of this stream, sorted according to natural order.
- ```toArray()``` -- returns an array containing the elements of this stream.
- ```count()``` -- returns the count of elements in this stream.
- ```forEach(Consumer<? super T> action)``` -- performs an action for each element of this stream.

